# Общий репозиторий для бэкенда "Развёртывание информационной платформы медицинских учреждений и разработка мобильного приложения"

## Правила взаимодействия со всеми репозиториями

### Взаимодействие с ветками

В репозитори присутствуют 3 основные ветки:

- `master` - основная, стабильные релизы.
- `dev` - выходящая из `dev`, разработка.

Создавайте ветки из `dev` для разработки новых
функциональностей или исправления ошибок.

Каждый коммит должен быть сделан в рамках соответствующей
ветки, а не в `master`, `dev`.
После завершения задачи сливайте ветку в основную ветку, желательно создав перед этим pull request.

### Оформления коммитов

Оформляйте коммиты в соответствии с
[Conventional Commits](https://www.conventionalcommits.org/ru/v1.0.0/),
который предоставляет структурированный формат для
описания изменений.

### Общие рекомендации к написанию кода

#### Именование

##### Переменные и функции

Используйте CamelCase для именования переменных и функций,
функции начиная с заглавной буквы, переменные со строчной.
Например: CalculateIncome, totalBalance.

##### Пакеты

Именуйте пакеты короткими и понятными именами, состоящими
из одного слова или сокращений, если это общепринято
(например, db, api, utils, usersrv, userrepo).

##### Именование ошибок

Именуйте переменные, представляющие ошибки,
с суффиксом Err. Например: err, dbErr.

#### Форматирование

##### Максимальная длина строки

Старайтесь придерживаться максимальной длины строки
в 80-100 символов. Это улучшает читаемость кода.

##### Форматирование комментариев

Используйте комментарии в стиле
[GoDoc](https://go.dev/blog/godoc) для документирования
вашего кода.

При необходимости добавляйте комментарии к функциям, методам и структурам,
описывая их назначение и возвращаемые значения.

Используйте комментарии в конце строк для пояснения
сложных участков кода.

#### Импорты

Группируйте импорты:

- Стандартные библиотеки Go.
- Внешние зависимости.
- Локальные пакеты.

Пример:

```go
import (
    "fmt"
    "os"

    "github.com/external/package"
    "github.com/your/project/localpackage"
)
```

В IDE желательно добавить к go fmt **go imports**, тогда не понадобится заботиться о группировке и сортировки импортов. 

#### Обработка ошибок

Всегда проверяйте ошибки и обрабатывайте их адекватно.

Не игнорируйте ошибки с помощью _, если это не обосновано.

Возвращайте ошибки из функций и методов, если они могут
вызвать проблемы.

#### Линтер
Перед каждым коммит необходимо прогонять линтер (настраивается в IDE или вручную с помощью команды ```golangci-lint run```).
Не следует игнорировать его замечания, они помогают сделать код читаемым и избежать глупых ошибок.

## Организация кода внутри проекта

### Clean Architecture

В качестве основной модели используем чистую архитектуру, сервис делится на несколько слоев:

- Controller - Компонент, который обрабатывает все входящие запросы(http, grpc, kafka, rabbitmq и т.д.) и отвечает за валидацию запроса.
- UseCase - Компонент, который реализует всю необходимую бизнес-логику(различные манипуляции с данными, походы в репозитории).
- Repository (infrastructure) - Компонент, который отвечает за взаимодействие с другими системами (базы данных, кэши, другие сервисы).

### DDD (Domain Driven Design)
Чтобы говорить с бизнесом на одном языке, мы отражаем все бизнес-сущности в коде, реализовывая внутри этих сущностей свою логику.

Бизнес сущности называют **доменами**. Их специфичную логику - **доменной логикой**.

В коде это означает, что:
- Каждая сущность представлена отдельной структурой
- Поля каждой структуры реализованы с помощью tiny-типов.

## Примерная архитектура проекта
![image](https://github.com/user-attachments/assets/3fc6f776-ad1b-41d8-b612-9c2add2674b9)

### Message Handler
Основная задача этого сервиса — обрабатывать сообщения пользователей и отправлять им ответы поддержки. Для выполнения своих функций сервис взаимодействует с **Core CRM**.

### Core CRM
Основной сервис системы, выполняющий следующие задачи:
1. Обработка сообщений: хранение, валидация и реализация бизнес-логики.
2. Интеграция с **GPT Proxy** для получения ответов от ML-модели.
3. Отправка событий в сервис аналитики.
4. Управление операторами и чатами.
5. Работа с вложениями через **Attachment Service**.
   Хранит данные о сообщениях, чатах и операторах.
   **Инфраструктура**: DB

### Yandex GPT Proxy
Этот прокси-сервис интегрируется с моделью Yandex GPT, чтобы получать предложенные ответы для операторов. На вход передаётся ID чата, а на выходе — готовый ответ. Сервис инкапсулирует всю логику взаимодействия с моделью: создание запроса на основе диалога и парсинг ответа.

### Task Distributor
Сервис для автоматического назначения чатов операторам.  
**Задача**: избавить операторов от необходимости вручную выбирать чаты, что ускоряет процесс и снижает вероятность ошибок при распределении чатов между несколькими операторами.
**Инфраструктура**: redis

#### Принцип работы:
1. Получает список чатов, ожидающих ответа.
2. Получает информацию об операторах, находящихся на смене.
3. Назначает чат самому менее загруженному оператору.

Сервис использует кэш для хранения настроек операторов (количество активных чатов, время окончания смены).

### Attachment Service
Сервис для хранения вложений от пользователей и операторов.  
**Задача**: инкапсулировать логику хранения бинарных данных в S3 и метаинформации в базе данных.  
**Инфраструктура**: S3, DB.

### Analytics Service
Сервис для сбора и анализа данных.  
**Задача**: собирать и обрабатывать аналитику, включая SLA, среднее время ответа оператора и частоту использования ML-подсказок.  
**Инфраструктура**: Column DB (ClickHouse).
